## 网络部分
#### TCP与UDP：
1.三次握手和四次挥手   
2.TCP和UDP的区别   
3.TCP保证可靠的传输机制   
4.TCP的拥塞控制和流量控制，拥塞控制中的四个算法   
5.SYN攻击以及解决办法   
6.Time_wait等待的意义   
7.回退N帧协议   
#### HTTP：
1.常见的状态码   
2.长连接短连接      
3.GET和POST的区别      
4.HTTP版本的区别   
5.格式   
#### DNS：   
1.DNS的解析过程   
2.DNS中的字段   
3.如果DNS解析出现错误，解决思路是什么？DNS的工作原理是什么？   
#### 其他常见问题：   
1.Ping和traceroute的工作原理   
2.路由和交换机的区别   
3.路由协议OSPF、BGP的区别      
4.输入网址后，背后发生了什么？    
5.B/S和C/S的区别    

## 总结
#### TCP与UDP：
##### 1.三次握手，四次挥手   
###### 三次握手   
根据TCP包头字段存在三个重要的标识ACK、SYN、FIN  
ACK：表示验证字段  
SYN：位数置为1，表示建立TCP连接   
FIN：位数置为1，表示断开TCP连接   
>第一次握手：  
由客户端发送建立TCP连接的请求报文，其中包含seq序列号，是由发送端随机生成的，并且将报文中
的SYN字段置为1，表示需要建立TCP连接。（SYN=1，seq=x，x为随机生成数值）   
第二次握手：   
由服务端回复客户端发送的TCP连接建立请求报文，其中包含seq序列号，是由回复端随机生成的。
并且将SYN置为1，而且会产生ACK字段，ACK字段数值是在客户端发送过来的序列号seq基础上加1
进行回复，以便客户端收到信息时，知晓自己的TCP建立请求已得到验证。（SYN=1，ACK=x+1，seq
=y，y为随机生成的数值）这里ack加1可以理解为时确认建立连接。   
第三次握手：   
客户端收到服务器端发送的TCP建立验证请求后，会使自己的序列号加1表示，并且再次回复ACK验证
请求，在服务端发送过来的seq上加1进行回复。（SYN=1，ACK=y+1，seq=x+1）   

状态：   
1.一开始，建立连接之前服务器和客户端都为CLOSED；   
2.服务器创建socket后开始监听，变为LISTEN状态；   
3.客户端请求建立连接，向服务器发送SYN报文，客户端的状态变为SYN_SENT；   
4.服务器收到客户端的报文后向客户端发送ACK和SYN报文，此时服务器的状态变为SYN_RCVD；   
5.然后，客户端收到ACK、SYN就向服务器发送ACK，客户端变为ESTABLISHED；  
6.服务器端收到客户端的ACK后变为ESTABLISHED。三次握手完成，连接建立。   
>LISTEN：等待从任何远端TCP和端口的连接请求。   
SYN_SENT：发送完一个连接请求后等待一个匹配的连接请求。   
SYN_RECEIVED：发送连接请求并且接收到匹配的连接请求以后等待连接请求确认。
ESTABLISHED：表示一个连接已建立，可以传输数据。   

>为什么需要三次握手？   
第三次握手是为了防止：在第二次握手后，由于网络原因，客户端迟迟没有收到服务器返回确认报文，这时
会放弃连接，重新启动一条新的连接。   
一句话，主要防止已经失效的连接请求报文突然又传送到了服务器，从而产生错误。

###### 四次挥手   
>第一次：   
客户端发送断开TCP连接请求的报文，其中报文中包含seq序列号，是由发送端随机生成的，并且
还将报文中的FIN字段置为1，表示需要断开TCP连接。（FIN=1，seq=x，x由客户端随机生成）   
第二次：   
服务端会回复客户端发送的TCP请求报文，其包含seq序列号，是由回复端随机生成的，而且会产生
ACK字段，ACK字段数值是在客户端发过来的seq序列号基础上加1进行回复。（FIN=1，ACK=x+1，seq=y
，y由服务端随机生成）   
第三次：   
服务端在回复完客户端的TCP断开请求后，不会马上进行TCP连接的断开，服务端会先确保断开前，所有
传输到客户端的数据是否已经传输完毕，一旦确认传输数据完毕，就会回复报文的FIN字段置1，并且产生
随机seq序列号。（FIN=1，ACK=x+1，seq=z，z由服务端随机生成）   
第四次：   
客户端收到服务端的TCP断开请求后，会回复服务端的断开请求，包含随机生成的seq字段和ACK字段，
ACK字段会在服务端的TCP断开请求的seq基础上加1，从而完成服务器端请求的验证回复。（FIN=1，ACK=
z+1，seq=h，h为客户端随机生成）   

状态：   
由于TCP连接是全双工的，断开连接会比建立连接麻烦。   
1.客户端先向服务器发送FIN报文，请求断开连接，其状态为FIN_WAIT1；   
2.服务器收到FIN后向客户端发送ACK，服务器的状态变成CLOSED_WAIT；   
3.客户端收到ACK后进入FIN_WAIT2状态，此时连接已经断开了一半。如果服务器还有数据要发送给客户端，
就会继续发送；   
4.直到发送完数据，就会发送FIN报文，此时服务器进入LAST_ACK状态；   
5.客户端收到服务器的FIN后，马上发送ACK给服务器，此时客户端进入TIME_WAIT状态；   
6.再过了2MSL长的时间后进入CLOSED状态，服务器收到客户端的ACK就进入CLOSED状态。   
至此，还有一个CLOSING状态没有出现：   
CLOSING状态表示：客户端发送了FIN，但是没有收到服务器的ACK，却收到了服务器的FIN，这种
情况发生在服务器发送的ACK丢包的时候，因为网络传输有时会有意外。   
>FIN_WAIT_1：等待远端TCP的连接终止请求，或者等待之前发送的连接终止请求的确认；      
FIN_WAIT_2：等待远端TCP的连接终止请求；   
CLOSE_WAIT：等待本地用户的连接终止请求；   
CLOSING：等待远端TCP的连接终止请求确认；   
LAST_ACK：等待之前发送给远端TCP的连接终止请求的确认；   
TIME_WITE：等待足够的时间以确保远端TCP接收到它的连接终止请求的确认。

>为什么需要2MSL时间？   
MSL（Maximum Segment Lifetime），TCP允许不同的实现可以设置不同的MSL值。   
第一，保证客户端发送的最后一个ACK报文能够到达服务器，因为这个ACK报文可能丢失，站在服务器的角度看来，我已经发送了FIN+ACK报文请求断开了，客户端还没有给我回应，应该是我发送的请求断开报文它没有收到，于是服务器又会重新发送一次，而客户端就能在这个2MSL时间段内收到这个重传的报文，接着给出回应报文，并且会重启2MSL计时器。   
第二，防止类似与“三次握手”中提到了的“已经失效的连接请求报文段”出现在本连接中。客户端发送完最后一个确认报文后，在这个2MSL时间中，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样新的连接中不会出现旧连接的请求报文。   

>为什么建立连接是三次握手，关闭连接确是四次挥手呢？   
建立连接的时候， 服务器在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。 
而关闭连接时，服务器收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了，所以己方可以立即关闭，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送，从而导致多了一次。

##### 2.TCP和UDP的区别
TCP面向连接（比如打电话要先拨号建立连接）；UDP是无连接的，即发送数据前不需要建立连接   
TCP提供可靠的服务，通过TCP传输的数据，无差错，不丢失，不重复，且按序到达；UDP尽最大努力交付，不保证数据的可靠性。   
TCP面向字节流；UDP面向报文的。    
TCP是点到点的；UDP支持一对一，一对多，多对一和多对多。   
TCP首部开销20字节；UDP首部开销小，只有8字节。   
TCP是全双工的可靠信道；UDP则是不可靠信道。   

##### 3.TCP保证可靠的传输机制   
确认和重传：接收方收到报文就会确认，发送方发送一段时间后没有收到确认就重传。   
数据校验   
数据合理分片和排序：TCP会按MTU合理分片，接收方会缓存为按序到达的数据，重新排序后再交给应用层。   
流量控制：当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。   
拥塞控制：当网络拥塞时，减少数据的发送。   

##### 4.TCP的拥塞控制和流量控制，拥塞控制中的四个算法   
>拥塞控制：发送方维持一个叫拥塞窗口cwnd（congestion window）的状态变量。拥塞窗口的大小
取决于网络的拥塞程度，并且动态的变化。发送方让自己的发送窗口等于拥塞窗口，另外考虑接收方的
接受能力，发送方窗口可能小于拥塞窗口。    
慢开始算法就是不要一开始就发送大量的数据，先探测一下网络的拥塞程度，也就是说由小到大逐渐
增加拥塞窗口的大小。    
拥塞避免算法让拥塞窗口缓慢增长，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1。    
ssthresh是一个慢开始的门限，当cwnd < ssthresh时，使用慢开始算法；cwnd > ssthresh时，使用拥塞避免算法；相等时，慢开始和拥塞避免任意切换。    
四种算法：慢开始，拥塞避免，快重传，快恢复

##### 5.SYN攻击以及解决办法
SYN攻击原理：TCP连接时，首先客户端发送一个SYN报文给服务端，然后服务端发送一个SYN-ACK包
回应客户端，最后，客户端返回一个ACK包来实现一次完整连接。在服务端返回SYN-ACK确认包时，
服务端可能接不到客户端回应的ACK包。这就是半开放连接，这种情况服务端会耗费系统内存来等待这个
没有回复的连接。SYN攻击就是通过ip欺骗，实现很多半开放连接，攻击者一直发送虚假的SYN请求包来
持续攻击，知道耗尽服务器的系统资源，服务器将不能再接收到任何其他请求。   
>解决办法：   
SYN cookies：主要设法消除半开连接的资源消耗，服务器通过特定算法把半开连接信息编码成‘cookie’，
随SYN-ACK消息一同返回给客户端，这样在建立连接前服务器不保存任何信息。如果客户端是正常客户端，
则会向服务器发送最后一次握手ACK信息，服务器收到验证‘cookie’的内容并且建立连接。如果客户端是正常客户端攻击者，
则不会向服务器反馈ACK，服务器没有任何损失。但是这样会降低正常客户的连接成功率。另一方面，如果
客户端给服务器的第三次握手细信息半路遗失，但客户端认为连接成功了，服务器认为没收到ACK。
